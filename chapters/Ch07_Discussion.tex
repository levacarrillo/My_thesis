\chapter{Discusión}
\section{Conclusiones}
\section{Trabajo Futuro}

\appendix
\section{Apéndice A: Código para el cálculo de la posición del balón}
\begin{lstlisting}
#include<ros/ros.h>
#include<ros/package.h>
#include<opencv2/opencv.hpp>
#include<sensor_msgs/Image.h>
#include<cv_bridge/cv_bridge.h>
#include<tf/transform_listener.h>
#include<std_msgs/Float32MultiArray.h>
#include<sensor_msgs/image_encodings.h>
#include<image_transport/image_transport.h>

#include<geometry_msgs/Pose.h>
#include<gazebo_msgs/ModelStates.h>


#define ball_radius 0.095


using namespace std;


double px, py, pz;
double e_x , e_y, v;
double x, y, theta, psi;
double roll, pitch, yaw;

double vertical_view, horizontal_view;
int camera_resolution[2] = {640, 480};


string file_pkg;
ros::Publisher pub_centroid_angle;
ros::Publisher  pub_ball_position;

cv::Scalar centroid;
cv::Mat   video_frame;
cv::Mat tracked_frame;
cv::Mat  ball_located;
vector<cv::Point> pixel_point;
cv::Mat kernel = cv::getStructuringElement(
cv::MORPH_ELLIPSE, cv::Size(5, 5));

cv::Mat hsv_min = cv::Mat_<int>::zeros(1, 3);
cv::Mat hsv_max = cv::Mat_<int>::zeros(1, 3);

geometry_msgs::Pose ball_model_pose;

bool get_hsv_values() {

    cv::FileStorage fs;
    fs.open(file_pkg + "/vision/hsv_values.xml", 
    cv::FileStorage::READ);

    if(!fs.isOpened()) { 
        cout << "There's no hsv_values.xml file..." 
        << endl;
        return false;
    }

    fs["hsv_min"] >> hsv_min;
    fs["hsv_max"] >> hsv_max;

    return true;
}

void get_centroid_angles() {

    std_msgs::Float32MultiArray centroid_angle;
    centroid_angle.data.resize(2);

    centroid[0] =   horizontal_view * (centroid[0] 
    - 0.5 * camera_resolution[0]) / (0.5*camera_resolution[0]);
    centroid[1] = - vertical_view   * (centroid[1] 
    - 0.5 * camera_resolution[1]) / (0.5*camera_resolution[1]);

    centroid_angle.data[0] = centroid[0]; 
    centroid_angle.data[1] = centroid[1];

    if(centroid[0] != -1 && centroid[1] != -1)
        pub_centroid_angle.publish(centroid_angle);
}

void compute_ball_position() { 

    std_msgs::Float32MultiArray position_msg;
    position_msg.data.resize(4);

    psi   = -centroid[1] + pitch;
    theta = -centroid[0] +  yaw ;
    
    x = px - pz * tan(1.5708 + psi) * cos(theta) 
    - ball_radius * cos(theta) / tan(psi);

    v = sqrt(pow(x, 2) + pow(pz, 2));
    y = v * tan(theta);

    //Exactly ball's pose
    position_msg.data[0] = ball_model_pose.position.x - 0.049;
    position_msg.data[1] = ball_model_pose.position.y + 0.065;
    //ball's pose calculated by vision system
    position_msg.data[2] = x;
    position_msg.data[3] = y;


    if(centroid[0] != - horizontal_view && centroid[1] 
    != - vertical_view)
        pub_ball_position.publish(position_msg);    
}

void callback_img(const sensor_msgs::ImageConstPtr& msg) {
    
    video_frame = cv_bridge::toCvShare(msg, "bgr8")->image;
    cv::imshow("Simulation view", video_frame);
    cv::cvtColor(video_frame, tracked_frame, CV_BGR2HSV);
    cv::inRange( tracked_frame,  hsv_min, hsv_max, 
    tracked_frame);
    cv::erode(   tracked_frame, tracked_frame, 
    kernel, cv::Point(-1, -1), 2);
    cv::dilate(  tracked_frame, ball_located, 
    kernel, cv::Point(-1, -1), 1);
    cv::imshow( "Ball located",ball_located);

    cv::findNonZero(ball_located, pixel_point);
    centroid = cv::mean(pixel_point);

    get_centroid_angles();
    compute_ball_position();
}

int getIndex(std::vector<std::string> v, std::string value) {
    for(int i = 0; i < v.size(); i++) {
        if(v[i].compare(value) == 0)
            return i;
    }

    return -1;
}

void callback_ball_position(const gazebo_msgs::ModelStates 
model_states) {

    geometry_msgs::Pose nimbro_pose;

    int nimbro_pose_index = getIndex(model_states.name, 
    "nimbro_op");
    int ball_model_index  = getIndex(model_states.name, 
    "teensize_ball");

    nimbro_pose     = model_states.pose[nimbro_pose_index];
    ball_model_pose = model_states.pose[ball_model_index];

    ball_model_pose.position.x += -nimbro_pose.position.x;
    ball_model_pose.position.y += -nimbro_pose.position.y;

}

int main(int argc, char**argv) {

    ros::init(argc, argv, "ball_position_simul");
    ros::NodeHandle nh("~");
    
    file_pkg = ros::package::getPath("config_files");

    pub_centroid_angle = nh.advertise<std_msgs::Float32MultiArray>
    ("/vision/ball_position/centroid_angle", 1000);
    pub_ball_position  = nh.advertise<std_msgs::Float32MultiArray>
    ("/vision/ball_position/ball_position",   1);

    ros::Subscriber ball_position_sub = nh.subscribe(
    "/gazebo/model_states", 1, callback_ball_position);
    

    if(!get_hsv_values()){
        ROS_ERROR("Please track colour with: 
        rosrun ball_tracker ball_tracker_simul");
        return -1;
    }        
    
    image_transport::ImageTransport it(nh);
    image_transport::Subscriber sub = it.subscribe(
    "/hardware/camera/image", 1, callback_img); 


    tf::TransformListener listener;

    while(ros::ok() && cv::waitKey(15)!=27) {

        if(!nh.hasParam("vertical_view")) { 
        cerr << "missing vertical_view param" << endl; 
        return -1; }
        if(!nh.hasParam("horizontal_view")) { 
        cerr << "missign horizontal_view param" << endl; 
        return -1; }
        if(!nh.getParam("vertical_view", vertical_view)) { 
        cerr << "invalid vertical_view param" << endl; 
        return -1; }
        if(!nh.getParam("horizontal_view", horizontal_view)) { 
        cerr << "invalid horizontal_view param" << endl; 
        return -1; }

        tf::StampedTransform transform;
        listener.waitForTransform("/right_foot_plane_link", 
        "/camera_optical", ros::Time(0), ros::Duration(10.0));
        listener.lookupTransform( "/right_foot_plane_link", 
        "/camera_optical", ros::Time(0), transform);
        transform.getBasis().getRPY(roll, pitch, yaw);

        px = transform.getOrigin().x();
        py = transform.getOrigin().y();
        pz = transform.getOrigin().z() + 0.05;

        ros::spinOnce();
    }

    
    return 0;
}

\end{lstlisting}


\section{Apéndice B: Código del estimador utilizando el Filtro de Kalman Extendido}

\begin{lstlisting}
#!/usr/bin/env python
import os
import json
import rospy
import numpy
import rospkg

from random import gauss
from std_msgs.msg import Bool
from std_msgs.msg import Float32MultiArray

flag_once = False
curr_time = 0
time_2_kick = 0
data_samples = 7
next_position = 0
distance_remaining = 0

time_movement = 0.15

abs_path = ""
all_positions = []
number_positions  = 0
first_measurement = True

g  = 9.81
dt = 0.0333
mu_d = 0.15

counter = 1

pub = rospy.Publisher('/robot_stop', Bool, queue_size=1000)

#Prediction parameters
print "-------------Initial state---------------"
Xn = numpy.array([[-0.3], 
				  [ 0.3]])
print "Xn"
print  Xn

#Covariance estimation matrix
Pn  = numpy.array([[0.1],
				   [0.1]])
print "Pn"
print  Pn

#Model noise
#Q = numpy.zeros((4,4))
Q = numpy.array([[0.000001],
				 [0.0]])

print "Q"
print  Q

#Process noise
w = numpy.array([[0.015],
	             [0.0]])


#Measurement noise
Rn = numpy.array([[0.00001],
	              [0.00001]])

print "Rn"
print  Rn

#Measurement vector
Z = numpy.array([[0.0], 
				 [0.0]])


def estimator():
	global Xn

	Xn = numpy.array([Xn[0] +  Xn[1]*dt + w[0],
    	Xn[1] - mu_d*g*dt + w[1]])


def prediction_state():
	global Xn, Xn1, Xn_, Pn, Pn1, Pn_
	'''print ---Prediction state---"'''

	Xn1 = numpy.array([Xn[0] +  Xn[1]*dt + w[0],
	Xn[1] - mu_d*g*dt + w[1]])



	Pn1 = numpy.array([Pn[0] + dt**2 * Pn[1]**2 + Q[0],
	Pn[1]+ Q[1]])


	# n-> n+1
	Xn_ = Xn1
 	Pn_ = Pn1



def correction_state():
	global Kn, Xn, Xn_, Xn1, Pn, Pn_, Z, counter

	print ""
	print "--- Correction State: ",counter,"---"
	counter += 1

	K0 = Pn_[0] / ( Pn_[0] + Rn[0] )
	K1 = Pn_[1] / ( Pn_[1] + Rn[1] )

	#Kalman gain
	Kn = numpy.array([K0,
		              K1])



	Xn[0] = Xn_[0] + Kn[0] * (Z[0] - Xn_[0])
	Xn[1] = Xn_[1] + Kn[1] * (Z[1] - Xn_[1])

	Pn[0] = (1 - Kn[0]) * Pn_[0]
	Pn[1] = (1 - Kn[1]) * Pn_[1]

	print "Xn[0]: ", float(Xn[0])
	#print "Xn[1]: ", float(Xn[1])
	
	'''print "Z"
	print  Z
	print "Xn_"
	print  Xn_
	print "Pn_"
	print  Pn_

	print "Kn"
	print  Kn
	
	print "Xn"
	print  Xn
	
	print "Pn"
	print  Pn'''


def measurement_input(data): 
	global first_measurement, number_positions, 
	Z, time_2_kick, curr_time, next_position, 
	distance_remaining, flag_once


	Z[1] = (data.data[3] - Z[0]) / dt
	Z[0] =  data.data[3] + gauss(0, 0.025)
  
	position_list = list()


	if(number_positions < data_samples):
		if not first_measurement:
			correction_state()

			position_list.append(data.data[1])
			position_list.append(float(Z[0]))
			position_list.append(float(Xn_[0]))
			position_list.append(float(Xn[0]))

			all_positions.append(position_list)
			number_positions += 1

			next_position = float(Xn[0]) -1
			curr_time = 0
			prediction_state();


	else:
		while(next_position < float(Xn[0])):
			next_position = float(Xn[0])
			if next_position < 0.1 :
				time_2_kick += dt

			estimator()

		if flag_once == False:
			print ""
			print "time_2_kick: ", time_2_kick
			flag_once = True

		if curr_time > time_2_kick - time_movement:
			pub.publish(Bool(True))

		curr_time += dt

	first_measurement = False


def save_ball_positions():
	global number_positions, all_positions, 
	time_2_kick
	with open(abs_path +
	'/scripts/kalman_estimator_data.txt','a') 
	as filehandle:
		for i in range(number_positions):
			json.dump(all_positions[i], 
			filehandle)
			filehandle.write("\n")

	print "------>", number_positions, 
	" positions saved :)" 


def kalman_estimator():
	global abs_path, all_positions
	rospy.init_node('kalman_estimator', anonymous=True)
	print "Starting kalman_estimator by Luis Nava"
	rospy.Subscriber("/vision/ball_position/ball_position", 
	Float32MultiArray, measurement_input)

	rospack = rospkg.RosPack()
	rospack.list()

	abs_path = rospack.get_path('ball_position')
	if os.path.exists(abs_path + 
	'/scripts/kalman_estimator_data.txt'):
		os.remove(abs_path + 
		'/scripts/kalman_estimator_data.txt')

	print "Loading positions..."
	rospy.spin()

	save_ball_positions()
	
if __name__ == '__main__':
	prediction_state()
	kalman_estimator()

\end{lstlisting}